# generated by datamodel-codegen:
#   filename:  terminals.json
#   timestamp: 2020-10-24T20:34:28+00:00

from __future__ import annotations
from typing import List, Dict, Optional, Union
from enum import Enum
from datetime import date
from pydantic import BaseModel, confloat, conint, validator


class OrderedEnum(Enum):
    def __ge__(self, other):
        if self.__class__ is other.__class__:
            return self.value >= other.value
        return NotImplemented
    def __gt__(self, other):
        if self.__class__ is other.__class__:
            return self.value > other.value
        return NotImplemented
    def __le__(self, other):
        if self.__class__ is other.__class__:
            return self.value <= other.value
        return NotImplemented
    def __lt__(self, other):
        if self.__class__ is other.__class__:
            return self.value < other.value
        return NotImplemented


class Product(OrderedEnum):
    ALCOHOL = "Álcool"
    ALUMINA = "Alumina"
    AMMONIA = "Amônia "
    BARK = "Barrilha"
    BAUXITE = "Bauxita"
    BIOFUEL = "Biodiesel"
    BUNKER_FUEL = "Combustível Marítimo"
    CELLULOSE = "Celulose"
    CEMENT = "Cimento"
    CHROME = "Cromo"
    CLINKER = "Clínquer"
    COAL = "Carvão"
    COKE = "Coque"
    COPPER = "Cobre"
    CORN = "Milho"
    DIESEL = "Diesel"
    FERTILIZERS = "Fertilizantes"
    GRANITE = "Granito"
    GASOLINE = "Gasolina"
    IRON = "Ferro"
    LIMESTONE = "Calcário"
    MANGANESE = "Manganês"
    PELLET = "Pelota"
    PHOSPHATE = "Fosfato"
    PIG_IRON = "Ferro Gusa"
    SAND = "Areia"
    SLAG = "Escória"
    SOY = "Soja"
    SOY_BRAN = "Farelo"
    STEEL = "Aço"
    SULFUR = "Enxofre"
    SUGAR = "Açúcar"
    WHEAT = "Trigo"
    WOOD = "Madeira"

    def __repr__(self):
        """
        Representation of Products enum as product value.
        """
        return f"{self.value}"

# COMBUST.REF.TANQUE(PERIG)

class Category(OrderedEnum):
    GRAINS = "Grãos"
    SUGAR = "Açúcar"
    FUELS = "Combustíveis"

    def __repr__(self):
        """
        Representation of Category of Products enum as category value.
        """
        return f"{self.value}"

    @staticmethod
    def mapping(product: Products, as_str=False):
        """
        Mapping category of product.

        Args:
            product (Products):
            as_str (bool, optional): [description]. Defaults to False.

        Returns:
            [type]: [description]
        """
        product_category = {
            Product.CORN: Category.GRAINS,
            Product.SOY_BRAN: Category.GRAINS,
            Product.SOY: Category.GRAINS,
            Product.SUGAR: Category.SUGAR,
            Product.ALCOHOL: Category.FUELS,
            Product.GASOLINE: Category.FUELS,
            Product.DIESEL: Category.FUELS,
            Product.BIOFUEL: Category.FUELS,
            Product.BUNKER_FUEL: Category.FUELS,
        }

        category = product_category.get(product)

        if category is not None and as_str:
            return category.name

        return category


class Modal(OrderedEnum):
    ROAD = "Rodoviário"
    RAILROAD = "Ferroviário"

    def __repr__(self):
        """
        Representation of Modal enum as value.
        """
        return f"{self.value}"


class Operation(OrderedEnum):
    RECEIVING = "Recebimento"
    EXPEDITION = "Expedição"

    def __repr__(self):
        """
        Representation of Operation enum as value.
        """
        return f"{self.value}"


class Rate(BaseModel):
    product: Product
    operation: Operation
    modal: Modal
    limits: List[conint(ge=0)]
    capacity: Optional[confloat(ge=0.0)] = None


# setup: Dict[Product, Dict[Product, float]]
# {Product.CORN: {Product.SOY: 4.0, Product.SOY_BRAN: 6.0}}
class CellSetup(BaseModel):
    old: Product
    new: Product
    time: confloat(ge=0.0)


# capacities: Dict[Product, Dict[str, float]]
# {Product.CORN: {"minimum": 0, "maximum": 30e3}}
class CellCapacity(BaseModel):
    product: Product
    minimum: confloat(ge=0.0)
    maximum: confloat(ge=0.0)

# timeouts: Dict[Product, float]
# {Product.CORN: 720.0}
class CellTimeout(BaseModel):
    product: Product
    timeout: confloat(ge=0.0)


class Cell(BaseModel):
    name: str
    id: str
    last_reset: date
    products: List[Product]
    setups: List[CellSetup]
    capacities: List[CellCapacity]
    timeouts: List[CellTimeout]


class Warehouse(BaseModel):
    name: str
    id: str
    products: List[Product]
    cells: List[Cell]

    @validator("cells")
    def all_cells_with_same_products(cls, cells):
        if len(cells) > 0:
            first = cells[0]

        all(
            set(cell.products) == set(first.products)
            for cell in cells
        )

        if



class InitialStock(BaseModel):
    product: Product
    client: str
    destiny_name: str
    destiny: str
    volume: conint(ge=0)


class ThirdCapacity(BaseModel):
    product: Product
    operation: str
    wagons: List[conint(ge=0)]


class Terminal(BaseModel):
    name: str
    id: str
    send: bool
    rates: List[Rate]
    warehouses: List[Warehouse]
    initial_stocks: List[InitialStock]


class ThirdTerminal(BaseModel):
    name: str
    id: str
    capacities: List[ThirdCapacity]


class Simulation(BaseModel):
    init_date: date
    end_date: date
    name: str
    id: str
    code: int
    terminals: List[Terminal]
    third_terminals: List[ThirdTerminal]

